# Flow Control Tasks

Top-Level tasks are always executed in sequence (as in conventional programming languages), however, the set of tasks
contained in the Flow subgroup can be used for modifying the execution flow of child tasks:

## Flow.Sequence
Executes all child steps in the same order as defined in the `Children` list. Useful for grouping related tasks or for
defining separate branches for Parallel or Select. Does not use any additional parameters.

## Flow.Parallel
Executes each of the child steps concurrently, as separate threads. The exact timing in which each thread starts or
ends is not guaranteed and cannot be considered replicable. The execution of Parallel stops when all threads are
completed (all threads are *joined* at the end). Does not use any additional parameters.
> All threads generated by Parallel make use of the same temporary folder (the one created for the experiment).
> Additional safeguards should be considered in order to avoid multiple threads accessing to the same file, where
> applicable.

## Flow.Repeat
Executes all child steps in the same order as defined in the `Children` list, for a pre-determined number of times.
Configuration values:
- `Times`: Number of times to repeat the execution of the children.

## Flow.While
Executes all child steps in the same order as defined in the `Children` list, while the specified condition is
evaluated as True. The configuration values are those on the [Defining Conditions](#Defining Conditions) section,
and, addidionaly:
- `MaxIterations`: Maximum number of iterations that can be run, unlimited by default. If defined, the loop will
exit after the value is reached, regardless of the evaluation of the condition.

## Flow.Select
Executes the first child in the `Children` list whose condition evaluates to True, or the last child (if present, when
there is a single missing condition in the configuration) if all other conditions evaluate to False. Configuration
values:
- `Conditions`: List of conditions, where each entry is a dictionary described in the
[Defining Conditions](#Defining Conditions) section. The task requires either one condition per child task, or exactly
one less, to implement a *default* or *else* branch.

# Defining Conditions
A Condition is defined as a dictionary with a set of expected fields. There are two kinds of conditions:

- **Evaluate** Conditions: These conditions are defined with the `Evaluate` field. It works similarly to the
[Run.Evaluate](/docs/3-2a_GENERAL_TASKS.md#Run.Evaluate) task, however, instead of publishing the result, it
checks if the expression evaluates to True.
  > If the evaluation raises an exception then the expression is considered False (a warning will be added to the log).

- **Key** Conditions: These conditions are defined with the `Key` field. Key Conditions can be used to check if
a certain key has been published, and if their value matches a regular expression.

One, and only one of `Evaluate` and `Key` must be part of a Condition. The following fields are optional:

- `Negate`: Boolean value that indicates if the condition should be negated. Defaults to False.
- `Pattern`: A regular expression for Key Conditions. Defaults to `None`.
  - If present, the value contained in `Key` is checked against the regex. A match makes the condition evaluate to True.
  - If not present, only the presence of `Key` is checked. If it exists, the condition evaluates to True.

> âš  Evaluate Conditions make use of the [eval](https://docs.python.org/3/library/functions.html#eval) built-in function:
> - Evaluate Conditions can execute arbitrary code.
> - Since the test cases are defined by the platform operators it is expected that no dangerous code will be executed,
> however, **exercise extreme caution, specially if variable expansion is used** as part of the condition.
